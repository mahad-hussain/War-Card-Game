deal: deck	"Class side method that takes an array of 52 integers, integers are from 1-13, represetning the 52 	cards in a standard deck of cards.	The class side method will handle the array and simulate the card game known  as war, between two 	players, with those 52 cards in the order they are currently in, in the array.		Overview: 	-> The original array will be changed so that all elements that are 1 in the array will become 14 	-> The method will first deal the cards in an alternating fashion to both players creating two 	decks 	of 26.	-> The game starts and the method looks for the first instance of war	-> When a war occurs the method checks to see if the each respective players cards are the same	if they are the war continues and more cards are added into the mix untill one player wins has a 	higher card when being compared, or all the cards are used and we return all the cards that were 	 	used sorted.	-> when a player whens the war/round, all the cards both players used in the war are handled then 	sorted in descending order then added to the winner of the rounds bottom of the deck	-> The game ends when a player runs out of cards in their deck or both players are unable to 	continue due to lack of cards	-> Before the game ends all elements that are 14 in the array are changed back to 1			The method returns the winning players deck after the game has been played out. All 52 cards as an 	array."	"scope: class-variables  &  class-instance-variables"			| p1 p2 cur addToC collecSort cardsOne cardsTwo remCards deckCopy collecCopy collecSortCase addToSize|			p1:= OrderedCollection new. 	p2:= OrderedCollection new.		"make all cards that are 1 equal to 14, this makes the 1/ace card the highest/strongest card when 	being compared during war and when sorted at the end of war"	deckCopy := deck copy.	1 to: (deckCopy size) do:[:a | 	((deckCopy at: a) = 1)	ifTrue: [ deckCopy at: a put: 14]	].		"Transcript show: deckCopy ; cr."			"gives each player there respective deck in an alternating fashion 	(cards at the end of the original stack start on the top of the two handed out decks)"	(deck size) to: 1 by: -2 do: [:a | p1 add: (deckCopy at: a)  ].	(deck size -1) to: 1 by: -2 do: [:a | p2 add: (deckCopy at: a)  ].			"Transcript show: p1; cr.	Transcript show: p2; cr.	"			"Starts the game"	"Gets the index of the card where each players decks are differing (The card at which war ends)"	"loop/game ends when one player has all the cards and a deck isEmpty"	[ ((p1 isEmpty) not ) & ((p2 isEmpty) not )]	whileTrue: [ 		"Only continues the game when none of the players decks are empty, prevents out of bounds error"	((p1 isEmpty) not ) & ((p2 isEmpty) not )	ifTrue: [  			"Stores the index of each card that is compared during war"		cur := 1.		"a sorted Collection that will be used when war cannot be completed between the two decks"	collecSortCase := SortedCollection sortBlock: [:a :c | a > c].			[ (p1 at: cur) = (p2 at: cur)]	whileTrue:	[ 	"when the current war card (card that is being compared) has has no more cards after it	the player with the higher number of total cards wins the war and takes all the cards from the 	round into their deck -> ifFalse [ ... ]. 	if the current war card has more cards in the deck after it that can be compared continue as 	normal -> ifTrue[...]	"	(cur < (p1 size -1)) & (cur < (p2 size -1))	"moves onto the next war card during this iteration"	ifTrue: [ cur:= cur+2 ]		"handles the two decks when a player cant continue doing more wars"	ifFalse: [ 		"default number of cards that should be added to the other players deck is 26"	addToSize := 26.	"depending on which player has more cards in the deck, that player wins the war and gets the 	remaining cards of the loser plus the cards it has already used in the war"	(p1 size >= p2 size)	ifTrue: [ addToSize := (p2 size) ]	ifFalse: [ addToSize := (p1 size) ].		"Transcript show: addToSize; cr."		"removes the cards used in war from each players deck and sorts them"	1 to: addToSize do:  [ :a| 	cardsOne := p1 removeFirst.	cardsTwo := p2 removeFirst.		collecSortCase add: cardsOne.	collecSortCase add: cardsTwo.	].	"Transcript show: collecSortCase ;cr."	"adds the used cards to the bottom of the winning players deck in a sorted fashion"	1 to: (collecSortCase size) do: [:z| 	remCards := collecSortCase removeFirst.	p1 addLast: remCards.	]. 		"handles the decks so that all the 14's become 1 again"	p1 isEmpty	ifTrue: [	collecCopy := p2 copy.	1 to: (collecCopy size) do:[:a | 	((collecCopy at: a) = 14)	ifTrue: [ collecCopy at: a put: 1]	]. 	]ifFalse: [	collecCopy := p1 copy.	1 to: (collecCopy size) do:[:a | 	((collecCopy at: a) = 14)	ifTrue: [ collecCopy at: a put: 1]	]. 	].		"Transcript show: collecCopy; cr."		"Returns the winning players final deck as an array"	^collecCopy asArray.	].		].	"Transcript show: cur; cr."		"Figures out which player won the round and which deck the cards should be added to"	(p1 at: cur) > (p2 at: cur)	ifTrue: [ addToC := p1]	ifFalse: [addToC := p2 ].		"a sorted collection that will sort the cards used in the war in descending order"	collecSort := SortedCollection sortBlock: [:a :c | a > c].		"removes the already played cards from each players deck and put them in descending order"	1 to: cur do: [ :a| 	cardsOne := p1 removeFirst.	cardsTwo := p2 removeFirst.		collecSort add: cardsOne.	collecSort add: cardsTwo.	].		"adds all the cards used during the round into the winner of the rounds deck (descending order)"	1 to: (collecSort size) do: [:z| 	remCards := collecSort removeFirst.	addToC addLast: remCards.	].		"Transcript show: p1; cr.	Transcript show: p2; cr.	"	].	].	"changes all the elements that are 14 back to its original state (1)"	p1 isEmpty	ifTrue: [	collecCopy := p2 copy.	1 to: (collecCopy size) do:[:a | 	((collecCopy at: a) = 14)	ifTrue: [ collecCopy at: a put: 1]	]. 	]ifFalse: [	collecCopy := p1 copy.	1 to: (collecCopy size) do:[:a | 	((collecCopy at: a) = 14)	ifTrue: [ collecCopy at: a put: 1]	]. 	].		"Returns the winning players deck as an array of 52 integers"	^(collecCopy asArray)